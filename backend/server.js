const express = require('express');
const cors = require('cors');
const multer = require('multer');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const axios = require('axios');
require('dotenv').config();
const { pool, initDB } = require('./db');
const { minioClient, bucketName, initMinio } = require('./minio');
const { connectRedis, getRedisClient } = require('./redis');
const { swaggerUi, specs } = require('./swagger');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Swagger
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

// Multer config for file upload
const upload = multer({ storage: multer.memoryStorage() });

// Kh·ªüi t·∫°o database, MinIO v√† Redis
initDB();
initMinio();
connectRedis();

/**
 * @swagger
 * /api/products:
 *   get:
 *     summary: L·∫•y danh s√°ch s·∫£n ph·∫©m
 *     tags: [Products]
 *     responses:
 *       200:
 *         description: Danh s√°ch s·∫£n ph·∫©m
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   price:
 *                     type: number
 *                   image:
 *                     type: string
 *                   category:
 *                     type: string
 *                   description:
 *                     type: string
 */
app.get('/api/products', async (req, res) => {
  const redisClient = getRedisClient();
  const cacheKey = 'products:all';
  
  try {
    // Ki·ªÉm tra cache Redis tr∆∞·ªõc
    if (redisClient && redisClient.isOpen) {
      const cachedProducts = await redisClient.get(cacheKey);
      if (cachedProducts) {
        console.log('üì¶ [REDIS] L·∫•y danh s√°ch s·∫£n ph·∫©m t·ª´ cache');
        return res.json(JSON.parse(cachedProducts));
      }
    }
    
    // N·∫øu kh√¥ng c√≥ cache, l·∫•y t·ª´ database
    console.log('üóÑÔ∏è [DATABASE] L·∫•y danh s√°ch s·∫£n ph·∫©m t·ª´ database');
    const result = await pool.query('SELECT * FROM products ORDER BY id');
    console.log(`Found ${result.rows.length} products`);
    
    // L∆∞u v√†o Redis cache (expire sau 5 ph√∫t)
    if (redisClient && redisClient.isOpen) {
      await redisClient.setEx(cacheKey, 300, JSON.stringify(result.rows));
      console.log('üíæ [REDIS] ƒê√£ l∆∞u danh s√°ch s·∫£n ph·∫©m v√†o cache');
    }
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching products:', error);
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
});

/**
 * @swagger
 * /api/products/{id}:
 *   get:
 *     summary: L·∫•y chi ti·∫øt s·∫£n ph·∫©m
 *     tags: [Products]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Chi ti·∫øt s·∫£n ph·∫©m
 *       404:
 *         description: Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m
 */
app.get('/api/products/:id', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM products WHERE id = $1', [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
});

/**
 * @swagger
 * /api/categories:
 *   get:
 *     summary: L·∫•y danh s√°ch danh m·ª•c
 *     tags: [Categories]
 *     responses:
 *       200:
 *         description: Danh s√°ch danh m·ª•c
 */
app.get('/api/categories', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM categories ORDER BY id');
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
});

/**
 * @swagger
 * /api/upload:
 *   post:
 *     summary: Upload h√¨nh ·∫£nh tr·ª±c ti·∫øp l√™n MinIO
 *     tags: [Upload]
 *     requestBody:
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: Upload th√†nh c√¥ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 imageUrl:
 *                   type: string
 */
app.post('/api/upload', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c upload' });
    }

    const fileName = `${Date.now()}-${req.file.originalname}`;
    
    await minioClient.putObject(
      bucketName,
      fileName,
      req.file.buffer,
      req.file.size,
      { 'Content-Type': req.file.mimetype }
    );

    const imageUrl = `http://localhost:9000/shopquanao/${fileName}`;
    console.log(`üì§ [UPLOAD] File uploaded to MinIO: ${fileName}`);
    res.json({ imageUrl });
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ message: 'L·ªói upload file', error: error.message });
  }
});

/**
 * @swagger
 * /api/upload/to-base64:
 *   post:
 *     summary: Upload file v√† chuy·ªÉn th√†nh base64 v·ªõi checksum
 *     tags: [Upload]
 *     requestBody:
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 base64:
 *                   type: string
 *                 checksum:
 *                   type: string
 *                 filename:
 *                   type: string
 *                 size:
 *                   type: number
 */
app.post('/api/upload/to-base64', upload.single('image'), async (req, res) => {
  const crypto = require('crypto');
  
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c upload' });
    }

    // T·∫°o base64
    const base64 = req.file.buffer.toString('base64');
    
    // T·∫°o checksum MD5
    const checksum = crypto.createHash('md5').update(req.file.buffer).digest('hex');
    
    console.log(`üîÑ [BASE64] File converted: ${req.file.originalname}, Size: ${req.file.size} bytes, Checksum: ${checksum}`);
    
    res.json({
      base64,
      checksum,
      filename: req.file.originalname,
      size: req.file.size,
      mimetype: req.file.mimetype
    });
  } catch (error) {
    console.error('Base64 conversion error:', error);
    res.status(500).json({ message: 'L·ªói chuy·ªÉn ƒë·ªïi file', error: error.message });
  }
});

/**
 * @swagger
 * /api/upload/from-base64:
 *   post:
 *     summary: Upload base64 l√™n MinIO v·ªõi checksum validation
 *     tags: [Upload]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               base64:
 *                 type: string
 *                 description: D·ªØ li·ªáu base64 c·ªßa file
 *                 example: "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=="
 *               checksum:
 *                 type: string
 *                 description: MD5 checksum ƒë·ªÉ validate
 *                 example: "5d41402abc4b2a76b9719d911017c592"
 *               filename:
 *                 type: string
 *                 description: T√™n file
 *                 example: "test.png"
 *               mimetype:
 *                 type: string
 *                 description: MIME type c·ªßa file
 *                 example: "image/png"
 *     responses:
 *       200:
 *         description: Upload th√†nh c√¥ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 imageUrl:
 *                   type: string
 *                 checksum:
 *                   type: string
 *                 verified:
 *                   type: boolean
 *       400:
 *         description: Checksum kh√¥ng kh·ªõp ho·∫∑c thi·∫øu d·ªØ li·ªáu
 */
app.post('/api/upload/from-base64', async (req, res) => {
  const crypto = require('crypto');
  
  try {
    const { base64, checksum, filename, mimetype } = req.body;
    
    if (!base64 || !checksum || !filename) {
      return res.status(400).json({ message: 'Thi·∫øu d·ªØ li·ªáu: base64, checksum, filename' });
    }

    // Chuy·ªÉn base64 th√†nh buffer
    const buffer = Buffer.from(base64, 'base64');
    
    // T·∫°o checksum ƒë·ªÉ validate
    const calculatedChecksum = crypto.createHash('md5').update(buffer).digest('hex');
    
    // Ki·ªÉm tra checksum
    if (calculatedChecksum !== checksum) {
      console.log(`‚ùå [CHECKSUM] Validation failed: expected ${checksum}, got ${calculatedChecksum}`);
      return res.status(400).json({ 
        message: 'Checksum kh√¥ng kh·ªõp', 
        expected: checksum, 
        calculated: calculatedChecksum 
      });
    }
    
    console.log(`‚úÖ [CHECKSUM] Validation passed: ${checksum}`);
    
    // Upload l√™n MinIO
    const fileName = `${Date.now()}-${filename}`;
    
    await minioClient.putObject(
      bucketName,
      fileName,
      buffer,
      buffer.length,
      { 'Content-Type': mimetype || 'application/octet-stream' }
    );

    const imageUrl = `http://localhost:9000/shopquanao/${fileName}`;
    console.log(`üì§ [MINIO] Base64 uploaded: ${fileName}, Size: ${buffer.length} bytes`);
    
    res.json({ 
      imageUrl, 
      checksum: calculatedChecksum,
      verified: true,
      filename: fileName
    });
  } catch (error) {
    console.error('Base64 upload error:', error);
    res.status(500).json({ message: 'L·ªói upload base64', error: error.message });
  }
});

/**
 * @swagger
 * /api/products:
 *   post:
 *     summary: Th√™m s·∫£n ph·∫©m m·ªõi
 *     tags: [Products]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               price:
 *                 type: number
 *               image:
 *                 type: string
 *               category:
 *                 type: string
 *               description:
 *                 type: string
 *     responses:
 *       200:
 *         description: Th√™m s·∫£n ph·∫©m th√†nh c√¥ng
 */
app.post('/api/products', async (req, res) => {
  const redisClient = getRedisClient();
  
  try {
    const { name, price, image, category, description } = req.body;
    const result = await pool.query(
      'INSERT INTO products (name, price, image, category, description) VALUES ($1, $2, $3, $4, $5) RETURNING *',
      [name, price, image, category, description]
    );
    
    // X√≥a cache khi th√™m s·∫£n ph·∫©m m·ªõi
    if (redisClient && redisClient.isOpen) {
      await redisClient.del('products:all');
      console.log('üóëÔ∏è [REDIS] ƒê√£ x√≥a cache products sau khi th√™m m·ªõi');
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error adding product:', error);
    res.status(500).json({ message: 'L·ªói th√™m s·∫£n ph·∫©m', error: error.message });
  }
});

/**
 * @swagger
 * /api/products/{id}:
 *   put:
 *     summary: C·∫≠p nh·∫≠t s·∫£n ph·∫©m
 *     tags: [Products]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               price:
 *                 type: number
 *               image:
 *                 type: string
 *               category:
 *                 type: string
 *               description:
 *                 type: string
 *     responses:
 *       200:
 *         description: C·∫≠p nh·∫≠t th√†nh c√¥ng
 *       404:
 *         description: Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m
 */
app.put('/api/products/:id', async (req, res) => {
  const redisClient = getRedisClient();
  
  try {
    const { name, price, image, category, description } = req.body;
    const result = await pool.query(
      'UPDATE products SET name = $1, price = $2, image = $3, category = $4, description = $5 WHERE id = $6 RETURNING *',
      [name, price, image, category, description, req.params.id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m' });
    }
    
    // X√≥a cache khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m
    if (redisClient && redisClient.isOpen) {
      await redisClient.del('products:all');
      console.log('üóëÔ∏è [REDIS] ƒê√£ x√≥a cache products sau khi c·∫≠p nh·∫≠t');
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error updating product:', error);
    res.status(500).json({ message: 'L·ªói c·∫≠p nh·∫≠t s·∫£n ph·∫©m', error: error.message });
  }
});

/**
 * @swagger
 * /api/products/{id}:
 *   delete:
 *     summary: X√≥a s·∫£n ph·∫©m
 *     tags: [Products]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: X√≥a th√†nh c√¥ng
 *       404:
 *         description: Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m
 */
app.delete('/api/products/:id', async (req, res) => {
  const redisClient = getRedisClient();
  
  try {
    const result = await pool.query('DELETE FROM products WHERE id = $1 RETURNING *', [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m' });
    }
    
    // X√≥a cache khi x√≥a s·∫£n ph·∫©m
    if (redisClient && redisClient.isOpen) {
      await redisClient.del('products:all');
      console.log('üóëÔ∏è [REDIS] ƒê√£ x√≥a cache products sau khi x√≥a s·∫£n ph·∫©m');
    }
    
    res.json({ message: 'X√≥a s·∫£n ph·∫©m th√†nh c√¥ng' });
  } catch (error) {
    console.error('Error deleting product:', error);
    res.status(500).json({ message: 'L·ªói x√≥a s·∫£n ph·∫©m', error: error.message });
  }
});

/**
 * @swagger
 * /api/orders:
 *   post:
 *     summary: T·∫°o ƒë∆°n h√†ng
 *     tags: [Orders]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               customer:
 *                 type: object
 *                 properties:
 *                   name:
 *                     type: string
 *                   phone:
 *                     type: string
 *                   address:
 *                     type: string
 *                   note:
 *                     type: string
 *               items:
 *                 type: array
 *                 items:
 *                   type: object
 *               total:
 *                 type: number
 *               orderDate:
 *                 type: string
 *     responses:
 *       200:
 *         description: T·∫°o ƒë∆°n h√†ng th√†nh c√¥ng
 */
app.post('/api/orders', async (req, res) => {
  try {
    const { customer, items, total, orderDate } = req.body;
    const result = await pool.query(
      'INSERT INTO orders (customer_name, customer_phone, customer_address, note, items, total, order_date, status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *',
      [customer.name, customer.phone, customer.address, customer.note || '', JSON.stringify(items), total, orderDate, 'pending']
    );
    res.json({ message: 'ƒê·∫∑t h√†ng th√†nh c√¥ng!', order: result.rows[0] });
  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({ message: 'L·ªói t·∫°o ƒë∆°n h√†ng', error: error.message });
  }
});

/**
 * @swagger
 * /api/register:
 *   post:
 *     summary: ƒêƒÉng k√Ω t√†i kho·∫£n
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               name:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *     responses:
 *       201:
 *         description: ƒêƒÉng k√Ω th√†nh c√¥ng
 *       400:
 *         description: Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng
 */
app.post('/api/register', async (req, res) => {
  try {
    const { email, password, name, phone, address } = req.body;
    
    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i
    const existingUser = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (existingUser.rows.length > 0) {
      return res.status(400).json({ message: 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng' });
    }

    // M√£ h√≥a m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // T·∫°o user m·ªõi
    const result = await pool.query(
      'INSERT INTO users (email, password, name, phone, address) VALUES ($1, $2, $3, $4, $5) RETURNING id, email, name, phone, address, role, created_at',
      [email, hashedPassword, name, phone, address]
    );
    
    res.status(201).json({ message: 'ƒêƒÉng k√Ω th√†nh c√¥ng', user: result.rows[0] });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ message: 'L·ªói ƒëƒÉng k√Ω', error: error.message });
  }
});

/**
 * @swagger
 * /api/login:
 *   post:
 *     summary: ƒêƒÉng nh·∫≠p
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: ƒêƒÉng nh·∫≠p th√†nh c√¥ng
 *       401:
 *         description: Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng
 */
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // T√¨m user theo email
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) {
      return res.status(401).json({ message: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng' });
    }
    
    const user = result.rows[0];
    
    // Ki·ªÉm tra m·∫≠t kh·∫©u
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ message: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng' });
    }
    
    // T·∫°o JWT token
    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({
      message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        phone: user.phone,
        address: user.address,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'L·ªói ƒëƒÉng nh·∫≠p', error: error.message });
  }
});

/**
 * @swagger
 * /api/news:
 *   get:
 *     summary: L·∫•y danh s√°ch tin t·ª©c
 *     tags: [News]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: S·ªë trang
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *         description: S·ªë b√†i vi·∫øt m·ªói trang
 *     responses:
 *       200:
 *         description: Danh s√°ch tin t·ª©c
 */
app.get('/api/news', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    
    const response = await axios.get('https://newsapi.org/v2/everything', {
      params: {
        q: 's∆°n OR paint OR coating OR "s∆°n n∆∞·ªõc" OR "s∆°n d·∫ßu" OR "ch·ªëng th·∫•m" OR "s∆°n epoxy" OR "b·ªôt m√†u" OR resin OR VOC',
        language: 'vi',
        sortBy: 'publishedAt',
        page: page,
        pageSize: limit,
        apiKey: process.env.NEWS_API_KEY || 'demo'
      }
    });
    
    const articles = response.data.articles.map((article, index) => ({
      id: `news_${page}_${index}`,
      title: article.title,
      description: article.description,
      url: article.url,
      urlToImage: article.urlToImage,
      publishedAt: article.publishedAt,
      source: article.source.name,
      content: article.content,
      author: article.author || 'Fashion Editor'
    }));
    
    res.json({ 
      articles,
      pagination: {
        page,
        limit,
        total: response.data.totalResults
      }
    });
  } catch (error) {
    console.error('News API error:', error.message);
    // Fallback data
    const fallbackArticles = Array.from({ length: 10 }, (_, i) => ({
      id: `fallback_${i + 1}`,
      title: `Tin t·ª©c ng√†nh s∆°n ${i + 1}`,
      description: `Th√¥ng tin m·ªõi nh·∫•t v·ªÅ c√¥ng ngh·ªá s∆°n v√† v·∫≠t li·ªáu ${i + 1}`,
      url: "#",
      urlToImage: `https://images.unsplash.com/photo-1562259949-e8e7689d7828?w=400&h=300&fit=crop&crop=center&auto=format&q=80&ixid=${i}`,
      publishedAt: new Date().toISOString(),
      source: "Paint Industry News",
      content: `N·ªôi dung chi ti·∫øt v·ªÅ c√¥ng ngh·ªá s∆°n m·ªõi ${i + 1}. B√†i vi·∫øt gi·ªõi thi·ªáu c√°c s·∫£n ph·∫©m s∆°n ti√™n ti·∫øn v√† ·ª©ng d·ª•ng trong x√¢y d·ª±ng.`,
      author: "Paint Industry Editor"
    }));
    
    res.json({
      articles: fallbackArticles,
      pagination: {
        page: 1,
        limit: 10,
        total: 50
      }
    });
  }
});

/**
 * @swagger
 * /api/news/{id}:
 *   get:
 *     summary: L·∫•y chi ti·∫øt tin t·ª©c
 *     tags: [News]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Chi ti·∫øt tin t·ª©c
 *       404:
 *         description: Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt
 */
app.get('/api/news/:id', async (req, res) => {
  try {
    const newsId = req.params.id;
    
    // Parse ID ƒë·ªÉ l·∫•y page v√† index
    if (newsId.startsWith('news_')) {
      const [, page, index] = newsId.split('_');
      
      // G·ªçi l·∫°i NewsAPI v·ªõi page t∆∞∆°ng ·ª©ng
      const response = await axios.get('https://newsapi.org/v2/everything', {
        params: {
          q: 's∆°n OR paint OR coating OR "s∆°n n∆∞·ªõc" OR "s∆°n d·∫ßu" OR "ch·ªëng th·∫•m" OR "s∆°n epoxy" OR "b·ªôt m√†u" OR resin OR VOC',
          language: 'vi',
          sortBy: 'publishedAt',
          page: parseInt(page),
          pageSize: 20,
          apiKey: process.env.NEWS_API_KEY || 'demo'
        }
      });
      
      const article = response.data.articles[parseInt(index)];
      if (article) {
        return res.json({
          id: newsId,
          title: article.title,
          description: article.description,
          content: article.content || `${article.description}\n\nB√†i vi·∫øt ƒë·∫ßy ƒë·ªß v·ªÅ ng√†nh s∆°n c√≥ th·ªÉ ƒë·ªçc t·∫°i: ${article.url}`,
          url: article.url,
          urlToImage: article.urlToImage,
          publishedAt: article.publishedAt,
          source: article.source.name,
          author: article.author || 'Paint Industry Editor'
        });
      }
    }
    
    // N·∫øu l√† fallback data
    if (newsId.startsWith('fallback_')) {
      const id = newsId.split('_')[1];
      return res.json({
        id: newsId,
        title: `Tin t·ª©c ng√†nh s∆°n ${id}`,
        description: `Th√¥ng tin m·ªõi nh·∫•t v·ªÅ c√¥ng ngh·ªá s∆°n v√† v·∫≠t li·ªáu ${id}`,
        content: `N·ªôi dung chi ti·∫øt v·ªÅ c√¥ng ngh·ªá s∆°n m·ªõi ${id}. B√†i vi·∫øt gi·ªõi thi·ªáu c√°c s·∫£n ph·∫©m s∆°n ti√™n ti·∫øn, k·ªπ thu·∫≠t thi c√¥ng v√† ·ª©ng d·ª•ng trong x√¢y d·ª±ng. Ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ c√°c lo·∫°i s∆°n ch·ªëng th·∫•m, s∆°n epoxy v√† c√°c gi·∫£i ph√°p b·∫£o v·ªá b·ªÅ m·∫∑t hi·ªán ƒë·∫°i.`,
        url: "#",
        urlToImage: `https://images.unsplash.com/photo-1562259949-e8e7689d7828?w=800&h=600&fit=crop&crop=center&auto=format&q=80&ixid=${id}`,
        publishedAt: new Date().toISOString(),
        source: "Paint Industry News",
        author: "Paint Industry Editor"
      });
    }
    
    res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt' });
  } catch (error) {
    console.error('News detail error:', error.message);
    // Fallback khi API l·ªói
    res.json({
      id: req.params.id,
      title: "Tin t·ª©c ng√†nh s∆°n",
      description: "Th√¥ng tin m·ªõi nh·∫•t v·ªÅ ng√†nh s∆°n",
      content: "N·ªôi dung chi ti·∫øt v·ªÅ tin t·ª©c ng√†nh s∆°n. Do l·ªói k·∫øt n·ªëi API, ch√∫ng t√¥i hi·ªÉn th·ªã n·ªôi dung m·∫∑c ƒë·ªãnh v·ªÅ c√°c s·∫£n ph·∫©m s∆°n v√† c√¥ng ngh·ªá m·ªõi.",
      url: "#",
      urlToImage: "https://images.unsplash.com/photo-1562259949-e8e7689d7828?w=800&h=600&fit=crop",
      publishedAt: new Date().toISOString(),
      source: "Paint Industry News",
      author: "Paint Industry Editor"
    });
  }
});

/**
 * @swagger
 * /api/test:
 *   get:
 *     summary: Ki·ªÉm tra k·∫øt n·ªëi database
 *     tags: [Test]
 *     responses:
 *       200:
 *         description: K·∫øt n·ªëi th√†nh c√¥ng
 *       500:
 *         description: K·∫øt n·ªëi th·∫•t b·∫°i
 */
app.get('/api/test', async (req, res) => {
  try {
    const result = await pool.query('SELECT NOW()');
    res.json({ message: 'Database connected!', time: result.rows[0].now });
  } catch (error) {
    res.status(500).json({ message: 'Database connection failed', error: error.message });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ Server ƒëang ch·∫°y tr√™n port ${PORT}`);
  console.log(`üìä Database: PostgreSQL`);
  console.log(`üìö Swagger UI: http://localhost:${PORT}/api-docs`);
});